<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/PipelineActions.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Contents**

- [Joining pipes](#joining-pipes)
- [ApplyTo(list)](#applytolist)
- [ConcatWith(list)](#concatwithlist)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Joining pipes

When you have two inputs that are needed for the next piece of functionality, you need a `JoinedPipe`. 

`JoinedPipe`s produce a `Tuple` of two inputs.

Note: If you are using `JoinedPipe` you need to call `Verify()` with the join.

<!-- snippet: joined_pipeline -->
```cs
var input1 = new InputPipe<long>("value1");
var input2 = new InputPipe<long>("value2");
var join = input1.JoinTo(input2);
```
<sup>[snippet source](/Refactoring.Pipelines.Test/PipelineTests.cs#L115-L119)</sup>
<!-- endsnippet -->

will produce:

![GraphViz of JoinedPipe](/Pipelines.Test/PipelineTests.JoinInputs.approved.dot.svg)

## ApplyTo(list) 

Sometimes you will want a special type of Join which takes one thing and applies it to each element of a separate list. 

For example, if you had:

<!-- snippet: ApplyTo_inputs -->
```cs
var apply = "#";
var to = new[] {1, 2};
```
<sup>[snippet source](/Refactoring.Pipelines.Test/PipelineTests.cs#L149-L152)</sup>
<!-- endsnippet -->

You can combine them to produce the following output:

<!-- snippet: ApplyTo_outputs -->
```cs
var result = "[(#, 1), (#, 2)]";
```
<sup>[snippet source](/Refactoring.Pipelines.Test/PipelineTests.cs#L154-L156)</sup>
<!-- endsnippet -->

For reference you can do this manually (although it creates a bad visualization):

<!-- snippet: ApplyTo_manual -->
```cs
prefix.JoinTo(values).Process(t => t.Item2.Select(i => Tuple.Create(t.Item1, i)));
```
<sup>[snippet source](/Refactoring.Pipelines.Test/PipelineTests.cs#L159-L161)</sup>
<!-- endsnippet -->

However, if you use the `ApplyTo()` method, you will end up with a much better-rendered result. 

![GraphViz of AppliedPipe](/Pipelines.Test/PipelineTests.ApplyTo.approved.dot.svg)

## ConcatWith(list) 

Sometimes you will want a special type of Join which takes two enumerables of the same element type and concatenates them into a list.

For example, if you had:

<!-- snippet: ConcatWith_inputs -->
```cs
var concat = new List<int> {1, 2};
var with = new[] {3, 4};
```
<sup>[snippet source](/Refactoring.Pipelines.Test/PipelineTests.cs#L182-L185)</sup>
<!-- endsnippet -->

You can combine them to produce the following output:

<!-- snippet: ConcatWith_outputs -->
```cs
var result = "[1, 2, 3, 4]";
```
<sup>[snippet source](/Refactoring.Pipelines.Test/PipelineTests.cs#L187-L189)</sup>
<!-- endsnippet -->

For reference you can do this manually (although it creates a bad visualization):

<!-- snippet: ConcatWith_manual -->
```cs
part1.JoinTo(part2).Process(t => t.Item1.Concat(t.Item2).ToList());
```
<sup>[snippet source](/Refactoring.Pipelines.Test/PipelineTests.cs#L192-L194)</sup>
<!-- endsnippet -->

However, if you use the `ConcatWith()` method, you will end up with a much better-rendered result. 

![GraphViz of AppliedPipe](/Pipelines.Test/PipelineTests.Concat.approved.dot.svg)

